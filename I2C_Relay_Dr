#include <Wire.h>
#include <WiFi.h>
#include <WebServer.h>

// --- KONFIGURACJA WiFi ---
const char* ssid = "*";
const char* password = "*";

// --- KONFIGURACJA I2C ---
#define I2C_SLAVE_ADDR 0x02
#define INTERRUPT_PIN 4
#define SDA_1 21
#define SCL_1 22

// --- KONFIGURACJA PRZEKAŹNIKÓW ---
const int relayPins[] = {13, 14, 27, 26, 16, 33, 32, 23, 12, 17, 19, 18};
const int numRelays = sizeof(relayPins) / sizeof(relayPins[0]);
uint16_t relayStates = 0; // Przechowuje stan bitowy (0-4095)

struct Room {
  String name;
  String icon;
};

// Przykładowe dane dla 12 przekaźników
Room roomData[] = {
  {"Sypialnia", "bed"}, {"Łazienka", "water_drop"}, {"Kuchnia", "microwave"}, 
  {"Łazienka2", "bathtub"}, {"Korytarz", "door_front"}, {"Biuro", "work"},
  {"Salon", "tv"}, {"SalonTV", "videogame_asset"}, {"Kinkiet", "wall_lamp"},
  {"Kuchnia 12v", "lightbulb"}, {"Przejscie", "hallway"}, {"Prysznic", "shower"}
};

WebServer server(80);

// --- FUNKCJE POMOCNICZE ---
void toggleRelay(int index) {
  if (index < numRelays) {
    int pin = relayPins[index];
    bool currentState = digitalRead(pin);
    digitalWrite(pin, !currentState);
    
    // Aktualizacja bitmaski relayStates
    if (!currentState) relayStates |= (1 << index);
    else relayStates &= ~(1 << index);

    Serial.printf("Przekaźnik %d (Pin %d) -> %s\n", index, pin, !currentState ? "ON" : "OFF");
  }
}

// --- OBSŁUGA I2C ---
void receiveEvent(int howMany) {
  while (Wire.available()) {
    byte relayIndex = Wire.read();
    toggleRelay(relayIndex);
  }
  // Sygnał przerwania dla Mastera
  digitalWrite(INTERRUPT_PIN, LOW);
  delayMicroseconds(50);
  digitalWrite(INTERRUPT_PIN, HIGH);
}

// --- OBSŁUGA WWW ---
void handleWebPage() {
  String html = R"rawliteral(
<!DOCTYPE html><html lang='pl'><head><meta charset='UTF-8'><meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'>
<title>SmartHome Hub</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
<style>
  body { font-family: 'Segoe UI', sans-serif; background: #1a1a1a; color: #e0e0e0; display: flex; flex-direction: column; align-items: center; margin: 0; padding-top: 20px; min-height: 100vh; -webkit-user-select: none; user-select: none; }
  .container { width: 90%; max-width: 900px; background: #282828; padding: 25px; border-radius: 12px; display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 20px; }
  .relay-item { display: flex; flex-direction: column; align-items: center; padding: 20px 10px; background: #333; border-radius: 10px; cursor: pointer; transition: 0.2s; touch-action: manipulation; }
  .relay-item:active { transform: scale(0.95); }
  .relay-item.active { background: #2e7d32; }
  .icon-display { font-size: 3em; color: #777; transition: 0.3s; pointer-events: none; }
  .active .icon-display { color: #FFA500; text-shadow: 0 0 10px #FFA500; font-variation-settings: 'FILL' 1; }
  .relay-name { font-size: 0.9em; margin-top: 10px; color: #ccc; pointer-events: none; }
</style></head><body>
  <h1>Panel Sterowania</h1>
  <div class='container' id='relayContainer'></div>
  <script>
    let relays = [)rawliteral";

  for (int i = 0; i < numRelays; i++) {
    bool s = (relayStates >> i) & 1;
    html += "{id:" + String(i) + ", name:'" + roomData[i].name + "', icon:'" + roomData[i].icon + "', state:" + (s ? "true" : "false") + "}";
    if (i < numRelays - 1) html += ",";
  }

  html += R"rawliteral(];
    function render() {
      const c = document.getElementById('relayContainer');
      c.innerHTML = '';
      relays.forEach((r, i) => {
        const d = document.createElement('div');
        d.className = `relay-item ${r.state ? 'active' : ''}`;
        d.innerHTML = `<span class="material-symbols-outlined icon-display">${r.icon}</span><span class="relay-name">${r.name}</span>`;
        d.onclick = () => { fetch(`/setRelay?id=${r.id}`); };
        c.appendChild(d);
      });
    }
    function update() {
      fetch('/getRelayStates').then(res => res.text()).then(data => {
        const states = parseInt(data);
        relays.forEach((r, i) => { r.state = (states >> i) & 1; });
        render();
      });
    }
    render(); setInterval(update, 2000);
  </script></body></html>)rawliteral";
  server.send(200, "text/html", html);
}

void setup() {
  Serial.begin(115200);

  // Konfiguracja pinów
  for (int i = 0; i < numRelays; i++) {
    pinMode(relayPins[i], OUTPUT);
    digitalWrite(relayPins[i], LOW);
  }
  pinMode(INTERRUPT_PIN, OUTPUT);
  digitalWrite(INTERRUPT_PIN, HIGH);

  // Połączenie WiFi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi połączone. IP: " + WiFi.localIP().toString());

  // Inicjalizacja I2C Slave
  if (!Wire.begin(I2C_SLAVE_ADDR, SDA_1, SCL_1, 400000)) {
    Serial.println("I2C Init Failed");
    while(1);
  }
  Wire.onReceive(receiveEvent);

  // Routing serwera WWW
  server.on("/", handleWebPage);
  server.on("/setRelay", []() {
    if (server.hasArg("id")) {
      int id = server.arg("id").toInt();
      toggleRelay(id);
      server.send(200, "text/plain", "OK");
    }
  });
  server.on("/getRelayStates", []() {
    server.send(200, "text/plain", String(relayStates));
  });

  server.begin();
  Serial.println("Serwer WWW wystartował.");
}

void loop() {
  server.handleClient();
  delay(2); // Małe opóźnienie dla stabilności WiFi
}
